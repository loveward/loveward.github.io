{"pages":[{"title":"About","text":"斯卡哈：看啥看，你也是神性弓！ 给大佬献上神性与弓","link":"/About/index.html"}],"posts":[{"title":"bbr加速","text":"废话不多说： 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh&amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 挺优秀的！","link":"/2019/04/04/bbr加速/"},{"title":"dango的unit-test","text":"首先unity-test还是很重要的，用于检测所有方法正常可用 django本身提供了一个方法来测试你写的各种方法 下面是官方的案例1234567891011121314from django.test import TestCasefrom myapp.models import Animalclass AnimalTestCase(TestCase): def setUp(self): Animal.objects.create(name=\"lion\", sound=\"roar\") Animal.objects.create(name=\"cat\", sound=\"meow\") def test_animals_can_speak(self): \"\"\"Animals that can speak are correctly identified\"\"\" lion = Animal.objects.get(name=\"lion\") cat = Animal.objects.get(name=\"cat\") self.assertEqual(lion.speak(), 'The lion says \"roar\"') self.assertEqual(cat.speak(), 'The cat says \"meow\"') 核心逻辑是1.定义自身的数据结构和内容 2.他这里是用了setup定义了两个animal 3.由test_animals_can_speak来测试两个animal的speak方法，并用assertEqual来对比调用方法和已知结果 这样就完成了对speak方法的测试 那么土方法是什么呢？我们都知道，一般项目的方法都是直接处理request的这样的话上面的方法就不适用了 因此django提供了RequestFactory用来提供request对象的支持123456789101112131415161718192021222324252627282930from django.contrib.auth.models import AnonymousUser, Userfrom django.test import RequestFactory, TestCasefrom .views import MyView, my_viewclass SimpleTest(TestCase): def setUp(self): # Every test needs access to the request factory. self.factory = RequestFactory() self.user = User.objects.create_user( username='jacob', email='jacob@…', password='top_secret') def test_details(self): # Create an instance of a GET request. # 生成一个 Get 类型的 request request = self.factory.get('/customer/details') # Recall that middleware are not supported. You can simulate a # logged-in user by setting request.user manually. request.user = self.user # Or you can simulate an anonymous user by setting request.user to # an AnonymousUser instance. request.user = AnonymousUser() # Test my_view() as if it were deployed at /customer/details response = my_view(request) # Use this syntax for class-based views. response = MyView.as_view()(request) self.assertEqual(response.status_code, 200) 然后再有，你还可以这样用 12345678910from django.test import TestCase#这里需要注意链接与urls.py对应啊class SimpleTest(TestCase): def test_details(self): response = self.client.get('/customer/details/') self.assertEqual(response.status_code, 200) def test_index(self): response = self.client.get('/customer/index/') self.assertEqual(response.status_code, 200) 测试发现基于unittest模块的内置测试发现。默认情况下，这将在当前工作目录下的任何名为 test*.py 的文件中发现测试。 编写测试后，使用test项目manage.py的命令运行它们： 1./manage.py test 或者你可以恶意满满的单独运行某个模块某个包某个类某个方法 123456789101112131415# Run all the tests in the animals.tests module$ ./manage.py test animals.tests# Run all the tests found within the 'animals' package$ ./manage.py test animals# Run just one test case$ ./manage.py test animals.tests.AnimalTestCase# Run just one test method#（一般test会有setup需要执行，但是这个run某个方法会不会运行setup我不知道）$ ./manage.py test animals.tests.AnimalTestCase.test_animals_can_speak#指定路径的方法$ ./manage.py test animals/","link":"/2019/03/25/dango的unit-test/"},{"title":"docker安装","text":"使用centos安装docker的时候。如果你直接1yum install docker 是可以直接安装上的，但是版本老到掉牙 这个时候可以这样 12345yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install -y docker-ce 这样版本就很新啦~ 之后简单配置就启用了 12345systemctl enable dockersystemctl start dockersystemctl status docker -l","link":"/2019/04/16/docker安装/"},{"title":"docker中的一些软件-jenkins","text":"docker中如何安装jenkins呢？portainer中的app template（应用模板）中有jenkins的模板 你可以直接部署，like this：模板中指定的jenkins版本为lts长期支持版本，选这个版本准没错 但是部署之后呢，会要求输入密码，因为jenkins会在神奇的位置创建一个密码 如果是敲命令，那你要先在众多container中找到jenkins1docker ps 然后记住containerID，在输入12docker exec -it xxx /bin/bashcat /var/jenkins_home/secrets/initialAdminPassword 才能看到密码， 但是伟大的portainer有这个： 只要在对应的docker container下面按这个按钮，就能直接进入container内部的bash程序 然后直接：1cat /var/jenkins_home/secrets/initialAdminPassword 这样就不用打开你的xshell，在辛辛苦苦找半天啦~你看我的密码这次就是这样： 随后我就可以开始配置我的jenkins了1哈哈哈哈，开心","link":"/2019/03/20/docker中的一些软件-jenkins/"},{"title":"npm-check的使用","text":"没啥说的1234#运行这个查看包的使用情况npm-check#运行这个更新包（然而比较暴力）npm-check -u 但是我发现1yarn upgrade 貌似也不错？？？","link":"/2019/03/22/npm-check的使用/"},{"title":"electron-vue","text":"electron-vue简直就是pc application的神器 啊 先说说怎么安装吧 官方写的是：12345678# Install vue-cli and scaffold boilerplatenpm install -g vue-clivue init simulatedgreg/electron-vue my-project#注意，这里my-project是指你自己项目的名字# Install dependencies and run your appcd my-projectyarn # or npm installyarn run dev # or npm run dev 装完之后就是差不多这样 红线划掉是我自己建的CI脚本和没什么乱用的协议 在/src/renderer目录下就是我们常见的vue框架啦，虽然有点变化，但是怎么引入必备的element-ui呢？先要添加包1yarn add element-ui 然后就是在/src/renderer/下的main.js12345678910111213141516171819202122import Vue from 'vue'import axios from 'axios'import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App'import router from './router'import store from './store'Vue.use(ElementUI);if (!process.env.IS_WEB) Vue.use(require('vue-electron'))Vue.http = Vue.prototype.$http = axiosVue.config.productionTip = false/* eslint-disable no-new */new Vue({ components: { App }, el: '#app', router, store, template: '&lt;App/&gt;'}).$mount('#app') 这里的这部分，是我添加vuex的，如果你不需要不用改123import store from './store'if (!process.env.IS_WEB) Vue.use(require('vue-electron'))Vue.http = Vue.prototype.$http = axios 主要还是确保以下内容存在：123456789101112131415import Vue from 'vue'import axios from 'axios'import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App'import router from './router'Vue.use(ElementUI);Vue.config.productionTip = falsenew Vue({ components: { App }, el: '#app', router, template: '&lt;App/&gt;'}).$mount('#app') 你别告诉我你连router都不用，好吧那你自己删减修改吧 随后就可以在template中快乐的使用elment-ui的组件了 怎么样？开心么？其他的包引入，应该也是同理！希望对你有用！！！ 顺便一说 electron-builder真的好用！","link":"/2019/03/22/electron-vue/"},{"title":"npm技巧——使用淘宝源","text":"npm命令换用淘宝源 123#是否需要root有待确认npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 啥？？？ ubunutu怎么安装npm？？？？ 123#需要root权限curl -sL https://deb.nodesource.com/setup_11.x | bash -apt install nodejs 使用yarn的话，就是 12#需要root权限npm i -g yarn","link":"/2019/03/30/npm技巧——使用淘宝源/"},{"title":"jenkins的配置","text":"首先说下jenkins的配置需要实现什么 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 他可以监听gitlab的push事件，并以此为点触发定义过程 简单的来说，他一直盯着gitlab某个项目的某个分支 然后我push代码到master，jenkins看到之后，就会从master拉取最新的代码然后编译 然后根据你后面指定的脚本，把编译出的东西，放到任何你指定的地方去 比如：安卓端，你编译好的apk，还有windows端，你编译好的安装包，需要放到cdn加速服务器中去，elementjs ，你编译好的页面文件，需要上到云主机上去，这个可怎么办呢？难道全都是手动？？非常麻烦吧！看着都头大…因此有了jenkins这个神器 jenkins说：这个世界要有光。于是世界便有了光 说了一大堆废话呢~那么说说jenkins的配置吧jenkins中gitlab监听部分配置 配置api token 配置项目地址和秘钥 编译，以安卓为例 详细的配置过程可以问我或者自行查阅文档或者直接参照团队的jenkins服务器（具体服务器在哪里自行查看哦~） 其他的例如nodejs，python等等的编译或者部署过程，可以自行百度","link":"/2019/03/20/jenkins的配置/"},{"title":"原地爆炸还有谁","text":"谁才是真正的无敌的那个人，就是我","link":"/2018/12/05/原地爆炸还有谁/"},{"title":"关于docker使用的一点工具","text":"docker是什么？ Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 当然，如果只是一个容器引擎，那并没有什么值得讨论，docker可以容纳的服务，多种多样 各种各样的内容才是docker变得繁荣的关键 但是初学者使用docker，尤其是那些对linux shell command不了解的新人，docker可以说是一个非常困难的存在，那么究竟应该如何降低这个门槛，来方便的使用docker呢？ 很多人给出了相当多的方案，但是我最喜欢的，无疑是对萌新最友好的：portainer 安装 portainer如果您不是root用户，那您还不速速搞个root权限？12docker volume create portainer_datadocker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 特别提醒：如果我没有记错的话，centos在12yum install docker#这个安装方式已经过时，请查看我另外一篇关于docker安装的文章获取最新的docker程序 之后，并不会启动docker你需要：123systemctl enable docker #启用systemctl start docker #启动systemctl status docker #查看状态 简单的说一下你可能需要的","link":"/2019/03/20/关于docker使用的一点工具/"},{"title":"天翼云 cenos初始化配置","text":"天翼云刚安装好的centos直接update会速度很慢 这个时候需要这样骚一下 123yum makecache fastyum update 这样之后就会很快啦~~~~","link":"/2019/04/16/天翼云-cenos初始化配置/"},{"title":"关于nodejs使用eslint","text":"eslint是一个可组装的JavaScript和JSX检查工具 用来检查js的代码错误和格式错误等等问题类似这样： 好吧，废话不多说 首先安装吧，一般来说如果是vs code用的话，直接安装 1npm i -g eslint 但是有的时候项目很多的话，而且编译和发布之前要做检测的话就要在项目内安装： 1npm install eslint --save-dev 完成安装之后就需要配置文件 12345#项目内安装./node_modules/.bin/eslint --init#全局安装eslint --init 安装好之后就要注意一下了 一般来说是需要插件的（当然需要自己用什么自己判断）你可以手动编辑一下，有选择的在“devDependencies”的下面加入以下插件 12345678910\"eslint\": \"^4.19.1\",\"eslint-config-standard\": \"^11.0.0\",\"eslint-friendly-formatter\": \"^4.0.1\",\"eslint-loader\": \"^2.0.0\",\"eslint-plugin-html\": \"^4.0.3\",\"eslint-plugin-import\": \"^2.12.0\",\"eslint-plugin-node\": \"^6.0.1\",\"eslint-plugin-promise\": \"^3.8.0\",\"eslint-plugin-standard\": \"^3.1.0\",\"eslint-plugin-vue\": \"^5.2.2\", 然后在.eslintrc.js中有选择的启用 1234plugins: [ 'html', 'vue'] 然后在package.json中可以加点指令来方便的使用 12345 \"scripts\": { \"lint\": \"eslint --ext .js,.vue -f ./node_modules/eslint-friendly-formatter src\", \"lint:fix\": \"eslint --ext .js,.vue -f ./node_modules/eslint-friendly-formatter --fix src\", \"postinstall\": \"npm run lint:fix\"} 上面的src是我的源代码目录因为使用了vue所以我才加了.vue的检查，如果没有的话，就不用加哦 然后每次 npm i完成之后都会运行监测~~~这样就非常优秀了 详细配置可以参照↓eslint官方文档","link":"/2019/03/29/关于nodejs使用eslint/"},{"title":"关于chocolatey的使用","text":"得choco者得天下 chocolatey是一个非常好用的工具，非常非常好用、 尤其是对于windows开发者来说，每次更换电脑后要整理各种各样的安装包很麻烦， chocolate可以给windows与centos和ubuntu近乎相同的安装体验 安装choco：（两种方法均需要管理员权限） 使用cmd.exe安装1@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; 使用PowerShell安装1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;)) 安装好之后就可以起飞了！安装choco有的包只需要1choco install &lt;包名&gt; 特别提醒，一般安装choco的包应该是需要管理员权限的 特别推荐1choco install chocolateygui 这是chocolatey的官方gui程序，那是真的好用，当你不知道包名或者要查查官方库里面有什么软件包的时候，这个GUI程序是真的棒棒 以后在教萌新如何安装软件的时候再也不用手把手了，直接choco install python nodejs …等等，超级多软件包可以安装，就连vs code都可以一条指令搞定，超级方便~","link":"/2019/03/20/关于chocolatey的使用/"},{"title":"如何开通自己的github blog，小白也看得懂","text":"首先哈，基于github.io 的blog的好处都有啥，我就不多说了吧 你可以自己写写东西，，记录自己学习的过程或者生活，还算挺不错的吧 我就从零开始说明一下要怎么做吧 1.准备安装工作准备好相关的程序 1.1 安装nodejs ，vscode ， gitNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。等下用的博客工具hexo就是nodejs下的一个工具 vscode是巨硬的ide，不知道的话可以百度 git版本管理工具，上传代码要用 1.2.1 windows上可以这么操作在windows上使用chocolatey，可以方便的安装各种开发者工具，chocolate的安装可以看我这篇关于chocolatey的使用在chocolatey上安装这三个软件，个人推荐在chocolatey-gui界面操作或者你可以使用命令12345678#安装nodejschoco install nodejs#安装vscodechoco install vscode#安装gitchoco install git#上述安装均需要管理员权限 1.2.2linux平台的话…你用的linux安装软件还需要我说？？？好吧。。。写一下吧1234567891011121314151617#on centos#安装nodejs 需要sudo啊sudo yum install epel-releasesudo yum install nodejssudo yum install npm#安装git（一般默认的都会带吧，如果你没得话，当我没说）sudo yum install git#安装vscode#这一步是导入巨硬的ascsudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" &gt; /etc/yum.repos.d/vscode.repo'#然后用yum命令安装vscodeyum check-updatesudo yum install code 123456789101112#on ubuntu sudo apt-get install nodejs#git一般都会默认系统带有的，如果你没，那你可能装了假的ubuntusudo apt-get install git#导入curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpgsudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpgsudo sh -c 'echo \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" &gt; /etc/apt/sources.list.d/vscode.list'安装sudo apt-get updatesudo apt-get install code 1.3安装hexo安装好nodejs之后就有npm工具了，可以用npm来安装hexo1234#使用npm 安装npm install -g hexo-clinpm install -g hexo-deployer-git#需要管理员权限 1.4使用一个神奇的工具 hexo-client地址在下面 点击→hexo-client on github当然你也可以自己复制：https://github.com/gaoyoubo/hexo-client 在他的release里面找你自己需要的包然后安装 或者直接点击→hexo-client release list 基本上全平台了吧！别跟我说为什么没有android/ios！！！！ 好的，先安装好吧， 然后选择一个你觉得合适的地方，建立你的工作路径名字叫work-path也好wp也好（其实就是在d盘也好，g盘也好，不要和你的小姐姐放在一起！）建立好一个空白的目录之后，进入在空白的地方右键打开git bash然后开始初始化的你的项目1234567891011#folder是指你准备给你的项目名字#初始化hexo init &lt;folder&gt;#进入你的博客路径cd &lt;folder&gt;#安装依赖npm install#可以是简单的任何的你喜欢的名字 比如就叫blog#那么命令就是 hexo init blog#不是 hexo init &lt;blog&gt; 初始化好之后在你的博客路径下，用下面的命令来查看你的空博客1hexo s 运行之后会给你一个127.0.0.1:xxx的地址你在浏览器打开就能看到了 2.使用github pagegithub page可以托管你的静态博客 刚才放出来的博客ip地址是127.0.0.1是本机，但是你要是想把页面放到公网上随时都能看，就要用到github page了 2.1注册一个github账号全英文看不懂的话，在chocolatey上下载chrome12#需要管理员权限choco install googlechrome 用chrome打开github有自动翻译√或者手动翻译网页空白处右键 注册好之后 新建一个repo 名字是 你的用户名.github.io我这里是感叹号因为我这个已经注册过了，你看这个博客头顶的链接 随后就是一个空的项目 然后不要急，要是用github，其实还有一个步骤没做那就是秘钥 2.2生成秘钥windows用户，在你的c盘Users目录下找到你的windows用户名的目录打开users一般在windows10中显示为中文差不多这样 然后打开它找到你的用户名字，新建一个空白的文件夹名字 叫做 .ssh 点是英文的点，ssh 是英文的ssh 一个字都不能差然后在打开，在空白的地方右键 打开git-bash 12#这里email就是你注册github时候使用的邮箱ssh-keygen -t rsa -C \"email@email.com\" 然后, next到底, 看到这些东西, 那就是成功了 1234567891011+--[ RSA 2048]------+|++o. ||=o .. ||..+... || o=... || o o=o. S ||o E. o.o || . .. o || . . || . |+-------------------+ 你会发现你的目录里面出现了id_rsa 和 id_rsa.pubpub是public的意思，也就是公钥，id_rsa就是你的私钥，两个都请复制保存好，然后源文件放在这里不要动 右键点击你的id_rsa.pub用记事本打开，把里面的内容复制一下，关掉 打开然后这里然后右边添加ssh key然后差不多是这样 把你刚才复制的公钥放进去title就随便输入你喜欢的吧 add之后就可以回到你刚才的空项目了这个时候点击注意你的链接应该git@github.com:xxxx/xxxx.github.io.git而不是https://xxxxxx前面的选项卡记得点清楚 把链接复制出来，存好，别乱搞，等下要用。（大功即将告成，是不是很激动啊~） 3.配置和使用Hexo和Hexo-Client差不多准备工作都备齐了那么接下来，在你的blog文件夹里面，空白处右键，打开vscode咱们配置一下这个hexo 默认目录会有一个_config.yml打开它，拉到最下面，添加1234deploy: type: git repo: git@github.com:xxxx/xxxx.github.io.git(这里写你刚才复制的ssh链接地址) branch: master 上面的theme是我自己选的和你无关，不用管它另外，yml是缩进敏感的，不要用tab，前面那点一定用两个空格 然后保存，退出 打开hexo-client如果我没有记错的话，hexo-client安装好之后会在桌面放个快捷链接双击点开会让你配置hexo的路径这时候就是你指定workpath的时候了 比如我的路径就是 注意，如果你实在不知道该怎么写就在vscode里面复制 _config.yml的路径 复制出来的路径把后面的_config.yml砍掉就是你的hexo路径配置好之后，你就可以写你的第一篇 blog了 写点什么好呢？ 哈哈随你喜欢，记得保存就好 4.发布在你的项目路径下打开shell也可以打开git bash也行，看你喜欢怎么样了常用的命令123456#生成文件hexo g#发布到githubhexo d#开发模式，可以在自己的浏览器快速查看hexo s 恭喜你大功告成，你很棒棒哦以后每次写好的blog先g再d，一条龙走你，什么？？？你说你还不会写md？？？？ 对不起，打扰了，我这就走 其他更高级的使用方式，如插件啊 主题啊，什么的，自己在hexo官网上探索吧hexo官网","link":"/2019/03/25/如何开通自己的github-blog，小白也看得懂/"}],"tags":[{"name":"vps","slug":"vps","link":"/tags/vps/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"unit-test","slug":"unit-test","link":"/tags/unit-test/"},{"name":"docekr","slug":"docekr","link":"/tags/docekr/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"portainer","slug":"portainer","link":"/tags/portainer/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"chocolatey","slug":"chocolatey","link":"/tags/chocolatey/"},{"name":"github","slug":"github","link":"/tags/github/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/学习/"},{"name":"为我妹妹写的教程","slug":"为我妹妹写的教程","link":"/categories/为我妹妹写的教程/"}]}